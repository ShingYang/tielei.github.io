---
layout: post
category: "other"
title: "编程世界的熵增原理"
date: 2016-08-21 01:00:00 +0800
published: true
---

> 歌者没有太多的抱怨，生存需要投入更多的思想和精力。  
> 宇宙的熵在升高，有序度在降低，像平衡鹏那无边无际的黑翅膀，向存在的一切压下来，压下来。可是低熵体不一样，低熵体的熵还在降低，有序度还在上升，像漆黑海面上升起的磷火，这就是意义，最高层的意义，比乐趣的意义层次要高。要维持这种意义，低熵体就必须存在和延续。

对科幻有一点了解的朋友也许已经猜到，这段描写出自《三体》。这想必是整部《三体》中最烧脑的一段文字了。

<!--more-->

这里面反复提到的“低熵体”，到底是一个怎样的存在呢？要理解它，我们首先要来讲讲“熵”这个概念。

据说，在很多物理学家的眼中，科学史上出现的最重要的物理规律，既不是牛顿三大定律，也不是相对论或者宇宙大爆炸理论，而是热力学第二定律。它在物理规律中具有至高无上的地位，因为它从根本上支配了我们这个宇宙演化的方向。这个定律指出：任何孤立系统，只能沿着熵增加的方向演化。

什么是熵？通俗来讲，可以理解为物体或系统的无序状态，或者混乱程度（简称乱度）。在没有外力干涉的情况下，随着时间的推移，一个系统的乱度将会越来越大。将冰块放入温水中，它终将融化，并与水交融为一体，因为温水的无序程度要高于冰块；一副扑克牌，即使按照花色和大小排列整齐，但经过多次随机的洗牌之后，它终将变得混乱无序；一间干净整洁的房间，如果长期没有人收拾的话，它将会变得脏乱不堪。

而生命体，尤其是智慧生命体（比如人类），却是典型的“低熵体”，能够维持自身和周围环境长期处于低熵的状态。可以想象，如果一所房子能够长期保持干净整洁，多半是因为它有一位热爱整洁且勤于家务的女主人。

纵观整个人类的发展史，人们将荒野开垦成农田，将河流疏导成生命的水源，结束散居生活从而聚集成村落。同时，人类又花费了数千年的时间，建立起辉煌的城市文明。城市道路和建筑楼群排列有致，轨道交通也井然有序；城市的地下管线错综复杂，为每家每户输送水电能源；清洁工人每天清扫垃圾，并将它们分门别类，运往恰当的处理地点……

所有的这一切，得以让我们这个世界远离无序状态，将熵值维持在一个很低的水平。

但是，一旦离开人类这个“低熵体”的延续和运转，这一切整齐有序都将不复存在。甚至是当人类的某个个体死亡之后，它的有机体也再不能维持自身。它终将随着时间腐烂，最终化为泥土。

---

记得在开发[微爱](http://welove520.com){:target="_blank"}App的过程中，我们曾经实现过这样一个主题皮肤的功能：

[<img src="/assets/photos_entropy/weiai_theme_screenshot.png" style="width:400px" alt="微爱主题设置功能截图" />](/assets/photos_entropy/weiai_theme_screenshot.png)

按照上面的截图所示，用户可以将软件的显示风格设置成多种主题皮肤中的一个（上面截图中显示了8个可选的主题）。当然，用户同一时刻只能选中一个主题。

我们的一位工程师按照这样的思路对存储结构进行了设计：每个主题用一个对象来表示，这个对象里存储了该主题的相关描述，以及该主题是否被用户选中（作为当前主题）。这些对象的数据最初都是从服务器获得的，都需要在本地进行持久化存储。对象的定义代码如下（伪码）：

```java
/**
 * 表示主题皮肤的类定义.
 */
public class Theme {
    //该主题的ID
    public int themeId;
    //该主题的名称
    public String name;
    //该主题的图片地址
    public String picture;

    //其它描述字段
    ......

    //该主题是否被选中
    public boolean selected;
}

```

上面截图界面中的主题选中状态的显示逻辑如下（伪码）：

```java
//参数：
//保存的各个主题数据，从持久化存储中获得
Theme[] themes;
//界面中显示各个主题的View层控件
View[] themeViews;

......

for (int i = 0; i < themeViews.length; i++) {
    if (themes[i].selected) {
        //将第i个主题显示为选中状态
        displaySelected(themeViews[i]);
    }
    else {
        //将第i个主题显示为未选中状态
        displayNotSelected(themeViews[i]);
    }
}
```

而用户重新设置主题的时候，选中逻辑如下（伪码）：

```java
//参数：
//保存的各个主题数据，从持久化存储中获得
Theme[] themes;
//界面中显示各个主题的View层控件
View[] themeViews;
//当前用户要选择的新主题的下标
int toSelect;

......

//修改当前选中的主题数据
themes[toSelect].selected = true;
//将当前选中的主题显示为选中状态
displaySelected(themeViews[toSelect]);

//找到旧的选中主题
int oldSelected = -1;
for (int i = 0; i < themes.length; i++) {
    if (i != toSelect && themes[i].selected) {
        oldSelected = i; //找到了
        break;
    }
}

if (oldSelected != -1) {
    //修改旧的选中主题的数据
    themes[oldSelected].selected = false;
    //将旧的选中主题显示为非选中状态
    displayNotSelected(themeViews[oldSelected]);
}

//最后，将修改后的主题数据持久化下来
saveToLocalStore(themes);
```

这几段代码看起来是没有什么逻辑问题的。但是，在用户使用了一段时间之后，有用户给我们发来了类似如下的截图：

[<img src="/assets/photos_entropy/weiai_theme_screenshot_abnormal.png" style="width:400px" alt="微爱主题设置功能异常选中截图" />](/assets/photos_entropy/weiai_theme_screenshot_abnormal.png)

竟然同时选中了两个主题！而我们自己不管怎样测试都重现不了这样的问题，检查代码也没发现哪里有问题。

这到底是怎么回事呢？

经过仔细思考，我们终于发现，按照上面这个实现，系统具有的“熵”比它的理论值要稍微高了一点。因此，它才有机会出现这种乱度较高的状态（两个同时选中）。

什么？一个软件系统也有熵吗？各位莫急，且听我慢慢道来。

热力学第二定律，我们通俗地称它为熵增原理，乃是宇宙中至高无上的普遍规律，在编程世界当然也不例外。

为了从程序员的角度来解释熵增原理的本质，我们仔细分析一下前面提到过的扑克牌洗牌的例子。我第一次看到这个例子，是在一本叫做《悖论：破解科学史上最复杂的9大谜团》的书上看到的。再也没有例子能够如此通俗地表现熵增原理了。

从花色和大小整齐排列的一个初始状态开始随机洗牌，扑克牌将会变得混乱无序；而反过来则不太可能。想象一下，如果我们拿着一副彻底洗过的牌，继续洗牌，然后突然出现了花色和大小按有序排列的情况。我们一定会认为，这是在变魔术！

系统的演变为什么会体现出这种明确的方向性呢？**本质上是系统状态数的区别**。

---

它所体现的系统演变的方向性，正是时间箭头的方向性。

熵增原理，是宇宙中至高无上的物理定律。编程也不例外。

应该让熵尽量小。

举例：多个主题选中问题；时光发送队列的判断开始问题（即发送队列里的状态维护问题）；发送与重发问题；创建和查询同时进行问题；上传下载非写在一起

---

一切都会腐化、损坏。

它更是时间之神手里的铁律。

代码随着时间腐化。

唯一能解决的方式，就是耗费我们的智能，不断地维持下去。

除非——

有朝一日，

AI出现。

到那时，我们的世界才能维持低熵永远运转下去。那时的低熵体，也许会像歌者一样，轻声吟唱起那首古老的歌谣：

> 我看到了我的爱恋  
> 我飞到她的身边  
> 我捧出给她的礼物  
> 那是一小块凝固的时间  
> 时间上有美丽的条纹  
> 摸起来像浅海的泥一样柔软  
> ……

（完）

